#N canvas 0 56 1360 712 24;
#X obj 130 20 text define -k code;
#A set 0.25 $v1*8000*4 sin(1000/($v1%4000)*2)*0.4+sin($v1*sin($v1))*sin(25/($v1%1000))*sin($v1/450)+($v1*2/($v1%(5+2)))%2*!($v1%1000/600%2)*sin($v1/800)*0.2+sin($v1*sin($v1%($v1/1000%5*4)))*($v1/4000%2)*!($v1%1000/700%2)*0.15+($v1/($v1/3000%2*31+31))%2*(1-$v1%1000/1000)*($v1/1000%8%5>0)*0.3
;
#N canvas 0 56 1360 712 stuff 1;
#X obj 397 393 s~ ramp;
#X obj 11 271 keyname;
#X obj 106 352 sel Alt_L;
#X obj 106 434 text get code;
#X msg 106 393 0;
#X obj 106 473 list;
#X msg 1045 95 \; pd dsp 1;
#X obj 1045 57 loadbang;
#N canvas 1 56 450 300 code 0;
#X obj 0 50 expexp $v1/($v1*10*8%4*($v1*10*4*8%2!=0)+1)*8000*40+8000*30
((sin($v1/($v1/($v1/3000%2*990+10)%5+1)*($v1/10000%2+1))*0.5*sin($v1/7000)+sin($v1/($v1/($v1/5000%2*900+100)%4+1)/($v1/12000%2+1))*0.4*sin($v1/9000))*sin($v1/31000)*0.5*32+2)*($v1/1000%8+2)%2*0.3*($v1/6000%4>1)*sin($v1%8000/1000)+sin(1000/($v1%(1000/($v1/7000%2+1)))*sin($v1/1500)*55)*0.25*!($v1/1000%8%5%2)+sin($v1*8%2*sin($v1*8%2))*sin(($v1/250%15+5)/($v1%($v1/3000%9%5*250+250)))*0.5+sin($v1*sin($v1*2%55))*sin(50/($v1%($v1/2000%7%6*500+500)))*($v1/6000%4<2)*0.5
;
#X obj 0 0 dummy;
#X restore 983 563 pd code;
#X obj 687 214 r~ wave;
#X obj 661 525 dac~;
#X obj 106 310 spigot;
#X obj 187 275 tgl 30 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X obj 397 314 r cps;
#X obj 688 457 clip~ -1 1;
#X msg 1045 170 \; pd-code clear \;;
#X obj 187 235 inlet;
#X text 280 8 Receiving port for msgs;
#X text 318 277 Cycles per second;
#X text 44 184 Read text object or msgs;
#X text 799 211 Output wave;
#X text 871 343 Custom EQ;
#X text 950 5 Init sound \, clear subp;
#X text 800 609 Subp for external dynamic creation;
#X text 103 638 Dynamic creation;
#X obj 12 8 netreceive 8080;
#X msg 106 512 \; cps \$1 \; pd-code clear \, obj 0 50 expexp \$2 \$3
\, obj 0 0 dummy \;, f 29;
#X obj 12 100 route #;
#X obj 397 354 phasor~;
#X obj 472 117 print;
#X obj 687 253 hip~ 4;
#X obj 853 490 env~;
#X floatatom 853 529 5 0 0 0 - - -, f 5;
#X obj 744 342 hip~ 40;
#X obj 636 342 lop~ 40;
#X obj 636 383 *~ 1;
#X obj 745 382 *~ 0.25;
#X connect 1 1 11 0;
#X connect 2 0 4 0;
#X connect 3 0 5 0;
#X connect 4 0 3 0;
#X connect 5 0 26 0;
#X connect 7 0 6 0;
#X connect 7 0 15 0;
#X connect 9 0 30 0;
#X connect 11 0 2 0;
#X connect 12 0 11 1;
#X connect 13 0 28 0;
#X connect 14 0 10 0;
#X connect 14 0 10 1;
#X connect 14 0 31 0;
#X connect 16 0 12 0;
#X connect 25 0 27 0;
#X connect 25 0 29 0;
#X connect 27 1 5 0;
#X connect 28 0 0 0;
#X connect 30 0 33 0;
#X connect 30 0 34 0;
#X connect 31 0 32 0;
#X connect 33 0 36 0;
#X connect 34 0 35 0;
#X connect 35 0 14 0;
#X connect 36 0 14 0;
#X restore 15 194 pd stuff;
#X obj 15 162 tgl 30 0 empty empty MACRO 35 7 0 10 -4034 -1 -1 0 1
;
#X text 0 72 You can edit your ramp code here or;
#X text 1 105 send a msg to 8080 port.;
#X text 12 397 Synthax: <cps> <ramp1> <ramp2>;
#X text 19 435 NOTE THAT <cps> CAN'T BE AN EXPRESSION;
#X obj 619 8 cnv 15 700 600 empty empty empty 20 12 0 14 -191407 -66577
0;
#X text 640 126 This means that all expressions operate over;
#X text 641 152 a regular increasing value or "ramp" (a single;
#X text 662 246 <cps> sets the constant speed of the phasor~;
#X text 659 271 <ramp1> and <ramp2> are expressions where;
#X text 660 297 $v1 represents the inlet signal:;
#X text 698 468 the output is the DAC.;
#X text 700 389 and the output goes to <ramp2>.;
#X text 700 363 For <ramp1> the input is the phasor~;
#X text 698 442 For <ramp2> the inlet is <ramp1> and;
#X text 641 178 phasor~ object) and its results go to the DAC.;
#X text 640 98 Rampcode is inspired in the bytebeat technique.;
#X text 787 25 * * * RAMPCODE 2 * * *;
#X text 69 579 github: /gabochi;
#X text 40 610 facebook: /gedeaudiovisual;
#X text 25 641 instagram: gabovinazza;
#X text 701 548 PHASOR~ to RAMP 1 to RAMP 2 to DAC~;
#X text 1 247 Toggle the MACRO to use the text object.;
#X text 1 279 Press <C-S> to save and <Lalt> to evaluate.;
#X connect 2 0 1 0;
