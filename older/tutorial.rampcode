# SETUP

# Open the patch.pd file with Pure Data and run the vim script before continue
# Press c-e to evaluate a line, c-a will stop the sound.

# BYTEBEAT SPIRIT

# Bytebeat is an unique synthesis technique that takes advantage of the most
# elementary bit manipulation instructions. That means that the same ops
# can function as sequencers, envelopes, modulators, mixers, pitch control, 
# measures, etc.  So, ideally, you need to understand those operations in 
# order to get the best out of bytebeat.  

# There are still many many ways of doing things and also many many things to 
# explore and discover but here you'll read about some important findings.

# THE TECHNICAL PART

# All operations will take 't' as the only variable.  't' means 'time' and
# it's just a counter that increases +8192 (=1<<13) per second by default.
# But keep in mind that the output of any bytebeat expression is truncated
# to fit the 0-255 amplitude spectrum, that is, 8-bit depth.  In fact, 8 bits
# are equivalent to 1 byte and that's why the name BYTEbeat.

# So, if you put just 't' in your expression, that will loop a 0 to 255 
# ascendent sawtooth wave (8192/256 = 32 Hz, something between B1 and C1,
# C1 minus 38 cents to be precise).  That will be our raw material.

# POSTFIX NOTATION AND OPERATORS

# For the sake of elegance and to avoid unnumerable parentheses we'll
# use RPN/postfix notation.  That operands will be accumulated in the stack
# and pop when an operator appear.

# t >> 1		== t1l
# t * ((t>>10)%5) 	== tt10r5Mm

# OPERATORS:

# l (<<) r (>>) 
# a (&) o (|) x (^) 
# + - d (/) m (*) 
# M (%)
# L (<) G (>) E (==) N (!=) 
# p (pow) i (int) s (sine) n (note)

# INTRODUCTION: SHIFTERS

# Did you notice that '8192 = 1<<13'?
# '<<' and '>>' are bitshifters.  They shift bits to the left or right.
# For example: 0100 (4) << 1 = 1000 (8), and 0100 (4) >> 2 = 0001 (1).
# It is very similar but not quite the same than dividing and multiplying by
# powers of two.  Let's change a little the last example to understand:
# 0101 (5) >> 2 = 0001 (1). See? That last bit is 'lost' when shifting.

# Anyway, it works and its less expensive than multiplying or dividing.  Of
# course, you'll always get an integer result.  Shifting will be the easiest
# way to increase or decrease 't' and change octaves or time measures.

# BRING THE BASE!

t1l
# same as t<<1
# Change the 1 to shift the octave

t3r
# same as t>>3
# This sawtooth is very slow, so we perceive it as a rhythmic thing.
# Full circle: since 't' is a freq, can be pitch and/or time fundamental.

# "Can I shift 't' places?"  Indeed, that would be interesting...
1234 t l
1234 t r
# Picked a random value to modulate

ttl
ttr
# Simplest modulation ever 

t9rtl
tt9rl
# Little variations

# LOGICAL BITWISE OPERATORS : AND
# Then, we have the basic bitwise operators. AND (&), OR (|) and XOR (^).
# They compare two values bit by bit.

# AND operator returns 1 where two bits are 1 (1010 & 0011 = 0010)
# Hence, the result will always be below the lesser operand.

# Limiter/Shaper
t127a
t128a
# same as 't&127' and 't&128'
# Powers of two will produce square waves.
# Powers of two minus one (1, 3, 7, 15, 31, 63, 127, etc.) a ramp and
# that will be very helpful for building counters/sequencers!

# 'Envelopes'
t2l t5r a

t2l 0t-5r a
# same as 't<<2 & -t>>5'
# Inverting 't' (0t-) is also a very helpful technique

# Trigger/Rhythm
t2l 0t-4ra -t6ra
t2l 0t-4ra -t3ra

t2l t7d1r a t11d1r a
# same as 't<<2 & t/7>>1 & t/11>>1', a rare polyrhythm

# Modulator
t3l t1l a 
t2l1.01m t1l a

t4l t3l1.005m a
# same as 't<<4 & (t<<3)*1.005'
# Not every bytebeat system will allow float point but that's a good one

t t3a l
t t0.968m7a l
# same as 't<<(t&3)' and 't<<(t*.968&7)' which you can say they're already
# sequencers.  Just changing the octave very fast, like we did before.

# Sequencers
t t10r3a l
t12r t10r7a r tm
t10r t12r7a r tm

t 0t-10r3a l
# same as 't << (-t>>10&3)'
# Now we're sequencing octaves but slowly, 't>>10' is kind of a 1/16 measure.

t t10r42a m
t 0t-10r42a m
# same as 't * (-t>>10&42)'
# The 42 is already a bytebeat classic!

t t9r42a 5M m
# same as 't * ((t>>9&42)%5)'
# There are many ways of spice up your sequences

# 12-TET SCALE SEQUENCES

# Here you have a melodic sequencer:
942 t11r3a4m r 15a n 2l
# same as 'pow(2, (942 >> (t>>11&3)*4 &15))/12.0) *t <<2'

# Don't panic!
# 'n' is a short for 'pow(2,X/12.0)*t', a 12-TET scale.
# &3 is the lenght of the sequence
# *4&15 moves by 4 bits to get the next hex digit
# 942 equals to 03AE hex, each hex digit mean X semitones from the fundamental
 
# Another little tweak:
942 t11r 1.37m 3a4m r 15a n 2l
# Same four notes but that 1.37 is now changing the sequence order
# '(t>>11) *1.37 &3'

# LOGICAL BITWISE OPERATORS: OR, XOR

# OR returns 1 if ANY of the compared bits is 1 (1010 | 0011 = 1011)
# The result will always be above the lesser operand.
# It is similar but not quite the same as adding and therefore it can be
# used to "mix voices", controll the amplitude and more, like &.

t1l t7r o
t1l t3r o
t1l t6m o
t2.001m t1l o
t t10rt12r o 3a l
30n46n o

# XOR returns 1 when ONLY ONE of the compared bits is 1 (1010 ^ 0011 = 1001)
# The results can be above or bellow the lesser operand, it can be used
# to produce a dirtier "mix", modulations and complexer sequences.

t1l t3r x
t1l t7r x
t1.01m t x
t3l t10rt12r x 3a d
30n43n x

# MORE RELATED STUFF

# If you're a pythagorean orthodox, don't use "n"

t3m
t3d 3l
0t-10r3a1+ tm t11r5M1+ d 3l

# Divide or multiply t by itself to generate 'whiter' noises

t t255a m
t t255a d
t t4r255a m
t t 1 12 l M m
t t 1 12 l M d

# That last one sounds like a kick, these could be useful:

t 0t-8r7a l 3r 
t 0t-8r7a m 
1024 t 2047 a d 128 m
1024 t 2047 a d s 256 m

# OR and XOR as 'mixers'
0t-10r3a1+tmt11r5M1+d3l127a t4r0t-9r7al o
0t-10r3a1+tmt11r5M1+d3l127a t4r0t-9r7al x
0t-10r3a1+tmt11r5M1+d2lt6ra127a t5r0t-9r7al o 
0t-10r3a1+tmt11r5M1+d2l0t-3ra127a t6r0t-9r7al x

# If you miss 'resolution' try classic FM
t 32 d t 32 d s 1024 t 1 r 1023 a d m + s 127 m 127 +

# Yes, don't forget the sine function

t t 120 d s 4 m + 4 l
# same as 't + sin(t/120)*4 <<4'

# More random stuff
t5r t x 18.3m 
t5r t a 199m
t3r t o 201m

# The wrapping glitch was exploited since the begining
t4r t a 1-
t6r t1r t x a 9-
t3r ta t13r7a-

# More float point easy modulations
t5l t8.005d 6M d

# Euclidean-like glitchy groove for goodbye
t10r31a3M0Et3lt255Mxmt10r15a5M4Ett7almo127at4r255a16Lt6lmot1l0t-3d3ra128aot10r13M-t6M+

