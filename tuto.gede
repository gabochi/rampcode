      ___                   ___           ___           ___           ___           ___           ___           ___           ___     
     /\__\      ___        /\__\         /\  \         /\  \         /\  \         /\  \         /\  \         /\  \         /\  \    
    /:/  /     /\  \      /:/  /        /::\  \       /::\  \       /::\  \       /::\  \       /::\  \       /::\  \       /::\  \   
   /:/  /      \:\  \    /:/  /        /:/\:\  \     /:/\:\  \     /:/\:\  \     /:/\:\  \     /:/\:\  \     /:/\:\  \     /:/\:\  \  
  /:/  /       /::\__\  /:/__/  ___   /::\~\:\  \   /:/  \:\  \   /:/  \:\  \   /:/  \:\__\   /::\~\:\  \   /::\~\:\  \   /::\~\:\  \ 
 /:/__/     __/:/\/__/  |:|  | /\__\ /:/\:\ \:\__\ /:/__/ \:\__\ /:/__/ \:\__\ /:/__/ \:|__| /:/\:\ \:\__\ /:/\:\ \:\__\ /:/\:\ \:\__\
 \:\  \    /\/:/  /     |:|  |/:/  / \:\~\:\ \/__/ \:\  \  \/__/ \:\  \ /:/  / \:\  \ /:/  / \:\~\:\ \/__/ \/__\:\/:/  / \/_|::\/:/  /
  \:\  \   \::/__/      |:|__/:/  /   \:\ \:\__\    \:\  \        \:\  /:/  /   \:\  /:/  /   \:\ \:\__\        \::/  /     |:|::/  / 
   \:\  \   \:\__\       \::::/__/     \:\ \/__/     \:\  \        \:\/:/  /     \:\/:/  /     \:\ \/__/        /:/  /      |:|\/__/  
    \:\__\   \/__/        ~~~~          \:\__\        \:\__\        \::/  /       \::/__/       \:\__\         /:/  /       |:|  |    
     \/__/                               \/__/         \/__/         \/__/         ~~            \/__/         \/__/         \|__|    


					presents this RAMPCODE tutorial by GEDE

v 0 . 3 . 3


livecodear.github.io

talk.lurk.org #live-coding-argentina

Livecodear (Telegram bot)

special THX to munshkr for his help and all the local crew 4 their constant support <3



"0.INITIAL NOTE (cycles)"

Time is everything in rampcode. You're always in a loop or cycle, a simple
counter that increases 8000 every cycle.

By default, you have 1 cycle per second but you can change it with r :

r @ 0.5;	half speed

r @ 1;	return to default

Changing the ramp speed will affect all the rest so feel free to change it
from time to time, sometimes gives you a nice surprise.

"1. CHANNELS AND EXPRESSIONS"


Rampcode has 8 channels (0-7). Send a msg to a channel with c:

c0 @ s(t) * 0.1; 	press ctrl+e here to evaluate
c0 @ 0;			and here to stop the sound

When we say that rampcode is inspired by bytebeat we mean all output is
a function/expression of time. Let's see...

c0 	tells that the following msg goes to channel 0
@  	separates arguments
s(t)	s=sin. Since time (t) here is a regular counter, it returns a sinewave.
* 0.1	multiplies the sine result, so it works as amplitude.
;	tells this is the end of the msg.

Understanding expressions is crucial since what you'll hear is result of them.
I'll give you some basic examples (if you don't get it DON'T WORRY, SKIP any
part of the tuto and take your time):

c0 @ s(t/2) *0.1;			divide or multiply to change pitch
c0 @ s(t*2) *0.1;
c0 @ 0;

c0 @ s(t/3) *0.05 + s(t/4) *0.05;	additive synthesis
c0 @ s(t/2) *s(t/500) *0.1;		AM
c0 @ s(t/2) *s(t/500) *10%10/10 *0.1;	same distorted
c0 @ a(s(t/2)) *s(t/500) *0.1;		another distortion (a=absolute)
c0 @ 0;

c0 @ s(t/4 +s(t/4) *2) *0.1;		2op FM
c0 @ s(t/4 +s(t/4) *s(t/1000) *2) *0.1;	3op FM
c0 @ 0;

c0 @ s(t*t) *0.05;			crazy stuff
c0 @ s(t*s(t)) *0.05;			noise
c0 @ 0;

c0 @ (t%100/100) *0.1;				saw wave
c0 @ (t%100/100) *0.1 + (t%101/101) *0.1; 	modulated by additive
c0 @ 0;

c0 @ (t%100 < 50) *0.1;				square wave
c0 @ (t%100 < t/200%100) *0.1;			pwm
c0 @ 0;

You see that expressions are not just math but also logic...
Some elegant examples of bytebeat using bitwise ops:

c0 @ ( t & t>>8 ) %64/64 *0.2;

c0 @ ( t*2 | t>>4 ) %256/256 *0.2;

c0 @ ( t ^ t%257 ) %256/256 *0.2;

c0 @ ( t*3 ^ t%250 | t>>4 ) %256/256 *0.2;

c0 @ ( t & t>>8 & t/16 ) %64/64 *0.2;

c0 @ 0;


"2. ENVELOPES"


Ok. Time to give some rhythm! 
Use e and E to select the curve and subdivission of the envelope:

c0@ s(t*t) *0.1 *e9; change the 9 with any 0-9 number and hear the difference.

c0@ s(t*t) *0.1 *E14; 1 is the subdivission and 4 the curve, play with them.

e is just a short for E8x

i and I have the same behaviour but inverted:

c0@ s(t*t) *0.1 *I19;


"3. COUNTERS"


' and # are counters.
Counters are very usefull, they can work as triggers or sequences.
They start from 1, you'll get why this is handy.

"a. Triggers:"


c0@ s(t*t) *0.1 *e4 *(#8<5); 	
If the counter 1-8 is less than 5 then gives 1: TRUE

c0@ s(t*t) *0.1 *e4 *(#8%3==1);
Yes, modulus is your friend :)

c0@ s(t*t) *0.1 *e4 *(#9>#4);	
A more interesting calculation

c0@ s(t*t) *0.1 *e2 *(#4==1 | #3==3); 
Combine them with | || & && or whatever.

' works like E for counters, first number is the time(in sbdv) of the count:

c0@ s(t*t) *e8 *0.1 *('12==1); first of 2 cycles gives TRUE

c0@ s(t*t) *e4 *0.1 *(#3<3 | '14==1); first of 4 cycles gives 1

c0@ 0;

"b. Sequences"

c0@ s(t/#8) *e3 *0.1;

c0@ s(t/(2-#8)) *e3 *0.1;

c0@ s(t/(2+'14)) *e3 *0.1;

c0@ s(t/(#8/#3)) *e3 *0.1;

c0@ s(t/(#8*#3)*'13) *e2 *0.1;

c0@ 0;


"4. RANDOM"


How can you resist the enchant of randomness? I can't, so you have one random
value per expression (you'll understand why later). 

c0@ s(t) *e3 *(x<0.5) *0.1;	x is float between 0-1
c1@ s(t/X8) *e3 *0.1;		X is interger between 1 and the next number

v0@2;	v1@4;		v controlls the random time(in sbdv) per channel
c0@ 0; c1@ 0;


"5. FX CHAIN"


There is a chain of 4 fxs per channel: filter -> delay -> s&h -> pan

v0@8; c0@ s(t/X8+s(t)) *e1 *0.1;

f0 @ 9 @ 1000;			filter: q (not an expression!) @ freq (hz)

f0 @ 5 @ x*4000;

f0 @ 0 @ 0;

d0 @ 0.5 @ 250;			delay: feedback @ ms

d0 @ x @ x*30;			random

d0 @ 0.5 @ t%150;		alien effect

d0 @ 0.8 @ t/200%200*0.1;	phaser	

d0 @ 0 @ 0;

h0 @ 1 @ 4000;			sample and hold: dry/wet @ hold (hz)

h0 @ '12==1 @ x*8000;		

p0 @ 0;				pan (0-1)
p0 @ x;
p0 @ 0.5;			center

c0 @ 0;

"6. SAMPLES"


Rampcode can manipulate samples from a wav file contained in /samples and
named correctly. 

l loads a file to a channel and w plays its samples according
to the specified expression. 

W is the total of samples in the file. Automatically, all samples expressions 
stay inside the range of the total samples loaded like (expression)%W.

With this tools you can build a simple player, a slicer, granular synth, etc.

l0 @ 6 ; 				load 5.wav as channel 0 
					(can't be an expression!)

w0 @ 0.1 @ t*5 ;			play at normal speed (*5) 
					and 0.1 amplitude.

w0 @ 0.1 @ W - t*5%W;			reverse

w0 @ 0.1 @ t*5 %(W/20) + #8*(W/8);	a slice sequencer

w0 @ 0.1 @ t*5 %(W/200) + t;		granular

w0 @ 0.1 @ (t*#4*4) % (W/200) + t;	granular sequence

w0 @ 0.1 @ t*3%(W/500) + W*x;		random offset

w0 @ e1*0.3 @ t*5%(W/(50*(X3+1))) +W*x;same with envelope and oct shifter


"7.EXAMPLE"

Let that random offset playing and run line by line 

c1 @ (s(t/#8*#3)+s(t/'26*2)*0.5) * 0.1 * e2 ; p1 @ x; d1 @ 0.5 @ 250;

c2 @ s(t/9) * e8 * (#8%5==1 & '12==1); f2 @ 1 @ 200;

c3 @ s(t*s(t%16)) * 0.1 *e1 *(#8==5 | '48==8);

c4 @ s(t/8 *#4 + s( t/8 /(1+#3) ) * s(t/1234) * 10) * 20%10/10 * 0.15 * e1 *('18<3); f4 @ 0.075 @ 100; d4 @ x*0.9 @ x*30;

c5 @ s(t*t) * 0.05 * e8 * ('14>2) ; d5 @ (x<0.5) @ 125/2;

c5@0;
c4@0;
c3@0;
c2@0;
c1@0;
c0@0;

Thanks for using rampcode, please don't hesitate to contact me and help me to improve it :)
