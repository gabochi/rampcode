
-- Here are some basic stuff and simple expressions so you can start rampcoding right away.

-- This is the elementary scheme: Ramp -> Expression -> Output

-- The ramp goes (by default) from 0 to 320000 in 8 seconds, this is 40000 per second. The actual value of the ramp is represented in any time as $v1 in the expressions.

-- Keep in mind that all output must be between -1 and 1 to fit the standard DSP values. That's easy, try this:

$v1 % 2 ;

-- Press <ctrl+enter> to evaluate the line and <alt+.> to stop the sound. You'll need it since this is a very loud and annoying sound.

-- The modulus (%) loops the input. So, while $v1 is constantly increasing, %2 returns 0 and 1 only (yes, a square wave!). Like this: 0 % 2 = 0, 1 % 2 = 1, 2 % 2 = 0, 3 % 2 = 1, and so on...

-- Now, let's change the pitch with a divission.

$v1 /100 %2 ;

-- Ok, by putting /100 before the modulus we're slowing down the ramp, so the results of %2 change at a lower frequency.

-- Bored? We're about to make it interesting. You can always replace a fixed value with a changing one. Let's change the fixed pitch with a drastical slide down.

$v1 /($v1%5000) %2 ;

-- Did you get it? We'll use modulus and divission a lot. $v1%5000 loops the ramp from 0 to 4999 like this: 4999 % 5000 = 4999, 5000 % 5000 = 0, 5001 % 5000 = 1, and so on... That means that the divissor increases fast and makes the pitch slide down very quickly. The result is a very percussive sound.

-- You can always loop a certain part of the ramp with %.

$v1%20000 /($v1%5000) %2 ;

-- But maybe you want to try some melodic or harmonic stuff. No problem:

$v1 /($v1/5000%4 *50) %2 ;

-- $v1/5000%4 is like a sequencer, the result will change each time the ramp increases 5000 (think 5000 as a 1/8 measure). *50 just gives a pitch change amount. Mess with these numbers and, maybe, you'll notice that you can play it very fast and get something like a chord:

$v1 /($v1/50%4 *50) %2 ;

-- Or a 8-bit arpeggio style:

$v1 /($v1/400%6 *5+5) %2 ;

-- In case you're wandering, +5 just avoids the silence since the first modulus result is always 0 and $v1/0 is.. well.. nothing.

-- In fact, just forget about the second divission and try different super fast arpeggios that generate harmonic textures.

$v1 /($v1%10) %2 ;

-- But what am I saying? You don't have to choose, you could have both, percussive and melodic in one expression. Just control the divission so it alternates small and big results.

$v1%25000 / ( $v1%( 7 + ($v1/10000%2*4993) ) ) %2 ;

-- I think you're now ready for envelopes.

$v1%2 * 0.1 ; -- * multiply to control the amplitude

$v1%2 * ( 1- $v1%5000/5000);

-- %5000/5000 is an increasing ramp from 0 to 1 in 1/8 measure. It can be inverted (1-) so you have an instant attack and then a release. Use power to set the release curve.

$v1%2 * pow( 1- $v1%5000/5000 , 10);

-- Add sequences to change the curve.

$v1%2 * pow( 1- $v1%5000/5000 , $v1/5000%10);

-- Let's apply this to the previous expression.

$v1%25000 / ( $v1%( 7 + ($v1/10000%2*4993) ) ) %2 * pow( 1- $v1%5000/5000 , $v1/5000%10);

-- Ok, that sounds nice! I'll give you one of my favorites tricks:

$v1%25000/($v1%(7+($v1/10000%2*4993)))%2* pow( ($v1/5000%8!=1) - $v1%5000/5000 , $v1/5000%10);

-- Now you have a condition ($v1/5000%8 != 1) instead of a fixed 1 that inverted the envelope. So, when the condition is 0 (false), the inversion does not work.

-- Well... time to go a deeper.

ramp @ $v1/2;

-- Yes, you just slow down the whole thing. "ramp" controls the ramp behavior with another expression. Play with it and make infinite patterns:

ramp @ $v1 / ($v1/15000%2+1);

ramp @ $v1 * ($v1/15000%2+1) / ($v1/20000%2+1);

ramp @ $v1/ ($v1/40000%2*0.5+1);

-- Not just the speed, make it jump to different slices like a sequencer.

ramp @ $v1 + ($v1/5000%8) * 15000;

ramp @ $v1 + ($v1/5000%7) * 15000;

ramp @ $v1 + ($v1/15000%3) * 5000;

-- Combine and experiment!

ramp @ $v1 / ($v1/15000%2+1) * ($v1/20000%2+1) + ($v1/10000%3) * 5000;

ramp @ $v1%(50000 + $v1/20000%2*320000);

ramp @ $v1%(50000 - ($v1/5000%3*5000) + $v1/20000%2*320000);

-- Another nice trick is to make a copy of the expression for a channel but change it a little to make an awesome stereo effect:

l @ $v1%30000/($v1%(14+($v1/10000%2*4993)))%2* pow( ($v1/5000%8!=1) - $v1%5000/5000 , $v1/5000%11+1);

-- Use "l" and "r" to assign expressions per channel.

-- "hz" and "amp" set the speed and amplitude of the ramp
-- 0.125 hz and 320000 (40000x8) amplitude are the defaults

hz @ 0.135;

amp @ 64000;

hz @ 0.45;

-- Defaults

hz @ 0.125; amp @ 320000; ramp @ $v1;



-- Some stuff I made while thinking about this document, take a look and change some values:

$v1 / ($v1%( sin($v1/9000)*5000+5000 )) / ($v1/10000%4*2+2) %2 * pow(1-$v1%5000/5000 , $v1/5000%10+2);

ramp@ $v1 + ($v1/5000%16%11 * 10000); hz @ 0.126;

ramp@ ( $v1/($v1/20000%2+1) ) * ( ($v1/5000%9==2) * ($v1/5000%2*40+2)+1 ) + $v1/5000%8*5000;

l@$v1%80000 /($v1%($v1/15000%3*5000+$v1/15000%2*5+5)) %2 * pow(1-$v1%5000/5000,4);

r@$v1%80000 /($v1%($v1/20000%3*5000+$v1/15000%2*5+5)) %2 * pow(1-$v1%5000/5000,$v1/5000%8+1);

ramp@ $v1;

-- That's all (for now)
