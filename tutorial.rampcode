
// Welcome to Rampcode !!!

// 0. INITIAL NOTES:

// This tutorial is intended to work within Atom
// Find the Atom package here:
// https://atom.io/packages/atom-rampcode
// Credit to Reo Matsumoto (github: /pndmix)

// Many of these techniques can be adapted to Greggman's html5bytebeat (select "floatbeat")
// https://greggman.com/downloads/examples/html5bytebeat/html5bytebeat.html

// 1. CHAIN AND SYNTHAX

// Rampcode is based on bytebeat, so basically you have loop with an increasing value (a counter or ramp) and all audio output is a direct result of an operation over the actual value of that ramp, a function.

// In fact, there are two functions. The result of the first is passed as input of the next:

// Ramp > Expression 1 > Expression 2 > Out

// This chain will be very helpful but, for now, just focus on the second one.

// The final output signal should be a float between -1 and 1. One difference from bytebeat is that the exceeding values are not wraped, they're simply clipped.

// Setup:
// c @ [constant] ; Increasing value, 8000 by default.
// hz @ [expression] ; Loop lenght in hz (times per second).

// Rampcode
// [expression] @ [expression] ; The main functions

// $v1 will represent the actual value of the ramp like "t" for "time" in bytebeat.

// EXAMPLE
// Keep the volume low!

// Press Ctrl+Alt+R to activate rampcode
// Press Shift+Enter to evaluate a lineal
// Press Alt+Enter to evaluate a block
// Alt+. will stop the sound at any point

hz @ 1.0 ; $v1*c @ $v1%2 ;

hz @ 1.0         ; // One second loop

$v1*c  @ $v1 %2  ;  // First map the ramp from 0-1 to 0-constant (8000 by default). Then, since %2 will return always 0 or 1 respectively, here we have our first square wave (I guess 4000hz).

// MODULO (%) !

// I can't stress enough how important is this operator. Technically, it returns the rest of a division but think of it as a "looper":

// 0%3 = 0, 1%3 = 1, 2%3 = 2, 3%3 = 0, 4%3 = 1, 5%3 = 2, etc

// You need to have this clear to understand almost everithing in Rampcode.

// 2. FREQUENCIES, FREQUENCIES EVERYWHERE!

// Indeed, it can be all reduced to the idea of manipulating frequencies so it is very important that you understand how to do it, some frequencies will act as tones, others will modulate, specific frequencies can be used as envelopes and some will control triggering and sequences.

// Let's keep the 1 hz * 8000 setup and see these different frequency implementations:

$v1 * c @ $v1 % 2 * sin($v1/300) * 0.5;
// Amplitude modulation, change the 300 for the frequency and the 0.5 for the final amplitude.

$v1 * c @ $v1 /8 %2 * 0.5 ;
// "Speeding" up or down the ramp, change the 8 value to control the pitch

$v1 * c @ $v1 * 800 %2 *0.5;
// Interesting glitches when you go over Nyquist.

$v1 * c @ $v1 % 2 * 0.5 * ! ($v1*4*2/c%2) ;
// Time measures, change the 4 to control the subdivision
// I put a NOT (!) to invert the first %2 result (which is 0)

// You'll notice that we're always using different combinations of the same basic operators, there's nothing but logic and math here so there are so many ways of achieving the same things, please be patient if you don't get it right away and try to understand the math and logic of each expression. I'll give you the same results but with different expressions:

$v1 * 8000 @ $v1 %2 / 2;
// Increase the /2 to low the volume

$v1 * 1000 @ $v1 %2 * 0.5;
// Change the frequency with the first expression ( * 1000)

$v1 * 8000 @ $v1 * 0.125 %2 * 0.5;
$v1 * 8000 @ $v1 / 0.00125 %2 * 0.5;
// Change the frequency by multiplying instead of dividing and viceversa.

$v1 * c @ (sin($v1) < 0 ) * 0.5 ;
// Another way of making a square wave, a true/false condition. Guess what happens if you change the condition dynamically:
$v1 * c @ ( sin($v1) < sin($v1*16/c) ) * 0.5;
// PWM, Pulse Width Modulation \o/

// Well, you've noticed that we can use sine functions too!

$v1 * c @ sin($v1) * 0.5;
// pure sine

$v1 * c @ sin($v1/8 + sin($v1/8) * sin($v1*3/c) * 9) *0.5;
// cool FM (3 op)

$v1 * c @ sin($v1/4) * sin($v1*12/c);
// AM

$v1 * c @ sin($v1 * sin($v1)) * 0.2;
// FM noise

$v1 * c @ sin($v1/16/($v1%8)) * 0.3;
// I don't know how to call this but I love it!

$v1 * c @ $v1 % 2 * 0.5 * ($v1%(c/4) < 500) ;
// Here I replaced the %2 for a condition and you can control the duration by changing the 500. I think this is the worst envelope you can imagine... I'll show you a better trick later.

// 3. COUNTERS

// Counters surely deserve an entire chapter because they're totally relevant in terms of sequencing (although, like anything here, you can make respectable music without them and I'm always trying to simplify things). The common formula I use goes like this:

// $v1 * (subdivision) / c % (steps [+1])

$v1 * c  @ $v1 / ($v1*8 /c%3 +1) %2 * 0.5;
// arpeggiator

$v1 * c @ $v1%2 * 0.5 * ($v1*8/c%3 == 0);
$v1 * c @ $v1%2 * 0.5 * ($v1*8/c%3 < 2);
// trigger

// press Ctrl+Alt to evaluate the whole block:
hz @ 1.0 / 8;
// set a longer loop (0.125hz = 8 seconds)
$v1 * c * 8
// remember to update the first expression (*8)
@ $v1 / ($v1*4/c%5+2) / ($v1/0.75/c%4+1) * ($v1/1.5/c%2+1) /2 %2 * 0.3;
// you can combine various counters to elaborate a melody

$v1 * c * 8
@ ($v1+sin($v1*80/c)*2) / ($v1*4/c%5+2) / ($v1/0.75/c%4+1) * ($v1/1.5/c%2+1) /2 %2 * (1-$v1*4%c/c) * 0.3;
// add vibrato FM and envelope

($v1 * c * 8)  + if($v1*8*8%4,$v1*c*8%8*abs(sin($v1)*5*($v1*8%4%2)),0)
@ ($v1*($v1/c%3%2+1)+sin($v1*80*($v1*8/c%2*9+1)/c)*2) / ($v1*($v1/c%5%4%3%2*39+4)/c%5+2) / ($v1/0.75/c%4+1) * ($v1/1.5/c%2+1) /($v1/c%3%2*2+2) %2 * pow(1-$v1*($v1*1.5/c%2*4+4)%c/c, $v1*8/c%3%2*4+1) * 0.42
+ sin(2000/($v1*2%c)) * 0.5
+ sin($v1 * sin($v1)) * !(3000 < $v1*(8-$v1*4/c%3%2*4)%c) * 0.12
+ sin($v1 * sin($v1%33)) * (1000 > $v1%c) * 0.16;
// well, that melody drove me here
// let's pretend this never happened...

// 4. ENVELOPES

// I'll show you my trick but it is very rustic indeed, it would be great if you find a better quality and, at least, equaly ecconomic way of doing envelopes. This is just a 0-attack envelope:

// (1 - $v1 * (measure) %c/c)

$v1 * c * 8 @ $v1%2 * (1-$v1*2%c/c) * 0.2;
// Change the *2 and try different measures.

$v1 * c * 8 @ $v1%2 * pow(1-$v1%c/c , 10) * 0.2;
// You can control the release curve with pow()

$v1 * c * 8 @ $v1%2 * ($v1%c/c) * 0.2;
// Of course, you can invert it too

$v1 * c * 8 @ $v1%2*(($v1*2/c%2) - $v1*8%c/c) *0.2;
// And combine

// 5. RAMP CONTROL

// Ok, now we're entering on special territory. This is a specific feature that Rampcode has. It sounds pretty simple, and it is, but you'll see why is this so useful.

hz @ 1.0 / 8;
// Just in case you were playing (I hope), time to return to the 8 seconds loop.

( $v1 * c * 8 ) / 1 % (c * 8) + c * 0
// / 1 controls the pitch (remember that's tone and speed)
// Having the c constant, we can speculate in patterns:
// % (c * 8) controls the lenght of the loop
// + c * 0 is the offset
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

// Ok, hope that was fun... Now try this:
( ($v1 + 800 *0) * c * 8 ) + $v1*c %5 *0
// Two ways to introduce some distortion
// Change the +800 (careful with this one, don't use minus nor larger numbers!) and the %5, activate and alter the effects with * (*1 *2 *3, etc)
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

( $v1 * c * 8 ) / 1 % (c / ($v1*8%2*2+2) ) + $v1*8*8%5*(c/8)
// Sequence length and offset combination with counters
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

( $v1 * c * 8 ) / ($v1*8*4%3*0.5+1) % (c / ($v1*8%2*2+2) ) + $v1*8*8%5*(c/8)
// Same but also with pitch
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

( $v1 * c * 8 ) / 1 % (c/($v1*8%2*7+1)) + $v1*8*8%6*(c/8) + $v1*c*8%(sin($v1*4)*10+12) * ($v1*8*8%3%2)
// Remove pitch but add distortion (also changed a little the sequence)
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

// I'll show you one last trick: All this can be handled with an if() to let the ground kick...
if ($v1*8*8%4, ($v1*c*8)/(3-$v1*4%3)+ $v1*c*8%(sin($v1*4)*10+12)*($v1*8%3%2), $v1*c*8)
--$v1*8*8%4 is 0 only on the first 1/8 measure of each pattern (when the kick and snare are!)
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 10) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

// Yeah, that was a lot of information but don't be affraid of trying things and please write me if you have any question or want to share your creations:

// gabochi
// gabriel.vinazza@gmail.com
// ig: @gabovinazza
// fb: /gedeaudiovisual
