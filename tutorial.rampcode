
// Welcome to Rampcode !!!

// 0. INITIAL NOTES:

// This tutorial is intended to work within Atom
// Find the Atom package here:
// https://atom.io/packages/atom-rampcode
// Credit to Reo Matsumoto (github: /pndmix)

// Many of these techniques can be adapted to Greggman's html5bytebeat (select "floatbeat")
// https://greggman.com/downloads/examples/html5bytebeat/html5bytebeat.html

// 1. CHAIN AND SYNTAX

// Rampcode is based on bytebeat, so basically you have loop with an increasing value (a counter or ramp) and all audio output is a direct result of an operation over the actual value of that ramp, a function.

// In fact, there are two functions. The result of the first is passed as input of the next:

// Ramp > Expression 1 > Expression 2 > Out

// This chain will be very helpful but, for now, just focus on the second one.

// The final output signal should be a float between -1 and 1. One difference from bytebeat is that the exceeding values are not wraped, they're simply clipped.

// Setup:
// c @ [constant] ; Increasing value, 8000 by default.
// hz @ [expression] ; Loop lenght in hz (times per second).

// Rampcode
// [expression] @ [expression] ; The main functions

// $v1 will represent the actual value of the ramp like "t" for "time" in bytebeat.

// EXAMPLE
// Keep the volume low!

// Press Ctrl+Alt+R to activate rampcode
// Press Shift+Enter to evaluate a lineal
// Press Alt+Enter to evaluate a block
// Alt+. will stop the sound at any point

hz @ 1.0 ; $v1*c @ $v1%2 ;

hz @ 1.0         ; // One second loop

$v1*c  @ $v1 %2  ;  // First map the ramp from 0-1 to 0-constant (8000 by default). Then, since %2 will return always 0 or 1 respectively, here we have our first square wave (I guess 4000hz).

// MODULO (%) !

// I can't stress enough how important is this operator. Technically, it returns the rest of a division but think of it as a "looper":

// 0%3 = 0, 1%3 = 1, 2%3 = 2, 3%3 = 0, 4%3 = 1, 5%3 = 2, etc

// You need to have this clear to understand almost everithing in Rampcode.

// 2. FREQUENCIES, FREQUENCIES EVERYWHERE!

// Indeed, it can be all reduced to the idea of manipulating frequencies so it is very important that you understand how to do it, some frequencies will act as tones, others will modulate, specific frequencies can be used as envelopes and some will control triggering and sequences.

// Let's keep the 1 hz * 8000 setup and see these different frequency implementations:

$v1 * c @ $v1 % 2 * sin($v1/300) * 0.5;
// Amplitude modulation, change the 300 for the frequency and the 0.5 for the final amplitude.

$v1 * c @ $v1 /8 %2 * 0.5 ;
// "Speeding" up or down the ramp, change the 8 value to control the pitch

$v1 * c @ $v1 * 800 %2 *0.5;
// Interesting glitches when you go over Nyquist.

$v1 * c @ $v1 % 2 * 0.5 * ! ($v1*4*2/c%2) ;
// Time measures, change the 4 to control the subdivision
// I put a NOT (!) to invert the first %2 result (which is 0)

// You'll notice that we're always using different combinations of the same basic operators, there's nothing but logic and math here so there are so many ways of achieving the same things, please be patient if you don't get it right away and try to understand the math and logic of each expression. I'll give you the same results but with different expressions:

$v1 * 8000 @ $v1 %2 / 2;
// Increase the /2 to low the volume

$v1 * 1000 @ $v1 %2 * 0.5;
// Change the frequency with the first expression ( * 1000)

$v1 * 8000 @ $v1 * 0.125 %2 * 0.5;
$v1 * 8000 @ $v1 / 0.00125 %2 * 0.5;
// Change the frequency by multiplying instead of dividing and viceversa.

$v1 * c @ (sin($v1) < 0 ) * 0.5 ;
// Another way of making a square wave, a true/false condition. Guess what happens if you change the condition dynamically:
$v1 * c @ ( sin($v1) < sin($v1*16/c) ) * 0.5;
// PWM, Pulse Width Modulation \o/

// Well, you've noticed that we can use sine functions too!

$v1 * c @ sin($v1) * 0.5;
// pure sine

$v1 * c @ sin($v1/8 + sin($v1/8) * sin($v1*3/c) * 9) *0.5;
// cool FM (3 op)

$v1 * c @ sin($v1/4) * sin($v1*12/c);
// AM

$v1 * c @ sin($v1 * sin($v1)) * 0.2;
// FM noise

$v1 * c @ sin($v1/16/($v1%8)) * 0.3;
// I don't know how to call this but I love it!

$v1 * c @ $v1 % 2 * 0.5 * ($v1%(c/4) < 500) ;
// Here I replaced the %2 for a condition and you can control the duration by changing the 500. I think this is the worst envelope you can imagine... I'll show you a better trick later.

// 3. COUNTERS

// Counters surely deserve an entire chapter because they're totally relevant in terms of sequencing (although, like anything here, you can make respectable music without them and I'm always trying to simplify things). The common formula I use goes like this:

// $v1 * (subdivision) / c % (steps [+1])

$v1 * c  @ $v1 / ($v1*8 /c%3 +1) %2 * 0.5;
// arpeggiator

$v1 * c @ $v1%2 * 0.5 * ($v1*8/c%3 == 0);
$v1 * c @ $v1%2 * 0.5 * ($v1*8/c%3 < 2);
// trigger

// press Ctrl+Alt to evaluate the whole block:
hz @ 1.0 / 8;
// set a longer loop (0.125hz = 8 seconds)
$v1 * c * 8
// remember to update the first expression (*8)
@ $v1 / ($v1*4/c%5+2) / ($v1/0.75/c%4+1) * ($v1/1.5/c%2+1) /2 %2 * 0.3;
// you can combine various counters to elaborate a melody

$v1 * c * 8
@ ($v1+sin($v1*80/c)*2) / ($v1*4/c%5+2) / ($v1/0.75/c%4+1) * ($v1/1.5/c%2+1) /2 %2 * (1-$v1*4%c/c) * 0.3;
// add vibrato FM and envelope

($v1 * c * 8)  + if($v1*8*8%4,$v1*c*8%8*abs(sin($v1)*5*($v1*8%4%2)),0)
@ ($v1*($v1/c%3%2+1)+sin($v1*80*($v1*8/c%2*9+1)/c)*2) / ($v1*($v1/c%5%4%3%2*39+4)/c%5+2) / ($v1/0.75/c%4+1) * ($v1/1.5/c%2+1) /($v1/c%3%2*2+2) %2 * pow(1-$v1*($v1*1.5/c%2*4+4)%c/c, $v1*8/c%3%2*4+1) * 0.42
+ sin(2000/($v1*2%c)) * 0.5
+ sin($v1 * sin($v1)) * !(3000 < $v1*(8-$v1*4/c%3%2*4)%c) * 0.12.
+ sin($v1 * sin($v1%33)) * (1000 > $v1%c) * 0.16;
// well, that melody drove me here
// let's pretend this never happened...

// You can also work with semitones aproximation (.0834), make chords and scales:

// $v1 <*,/> [int](1 + .0834 * X)

// Try changing the 2.25

$v1*c*8
@
$v1/8*(1+.0834*int($v1*8/c%5 *    2.25     ))%2*0.25;

// Here, the opossite direction, change the 3

$v1*c*8
@
$v1/4
/ (1+.0834*int($v1*16/c%3 * 3  + ($v1/2/c%3) ))%2*0.25;

// Combine the intergers and the semitones aproximation

$v1*c*8
@
$v1/4/($v1*2/c%3+1)
*(1+.0834*int($v1*8/c%5*  2.25  ))%2*0.25;

$v1*c*8
@
$v1 / ($v1/c%4+1)
/ (1+.0834*int($v1*32/c%3 * 3  + ($v1/2/c%3) ))%2*0.25;



// 4. ENVELOPES

// I'll show you my trick but it is very rustic indeed, it would be great if you find a better quality and, at least, equaly ecconomic way of doing envelopes. This is just a 0-attack envelope:

// (1 - $v1 * (measure) %c/c)

$v1 * c * 8 @ $v1%2 * (1-$v1    *2   %c/c) * 0.2;
// Change the *2 and try different measures.

$v1 * c * 8 @ $v1%2 * pow(1-$v1%c/c , 10) * 0.2;
// You can control the release curve with pow()

$v1 * c * 8 @ $v1%2 * ($v1%c/c) * 0.2;
// Of course, you can invert it too

$v1 * c * 8 @ $v1%2*(($v1*2/c%2) - $v1*8%c/c) *0.2;
// And combine

// 5. RAMP CONTROL

// Ok, now we're entering on special territory. This is a specific feature that Rampcode has. It sounds pretty simple, and it is, but you'll see why is this so useful.

hz @ 1.0 / 8;
// Just in case you were playing (I hope), time to return to the 8 seconds loop.

( $v1 * c * 8 ) / 1 % (c * 8) + c * 0
// / 1 controls the pitch (remember that's tone and speed)
// Having the c constant, we can speculate in patterns:
// % (c * 8) controls the lenght of the loop
// + c * 0 is the offset
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

// Ok, hope that was fun... Now try this:
( ($v1 + c/8 *0) * c * 8 ) + $v1*c*8 %5 *2*0
// Two ways to introduce some distortion
// Change the c/8 (careful with this one, don't use minus nor large numbers!) and the %5, activate and alter the effects with * (*1 *2 *3, etc)
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

($v1*c*8) /1
% (c / ($v1*8%2*2+2) ) + $v1*8*8%5*(c/8)
// Sequence length and offset combination with counters
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

($v1*c*8)
/ ($v1*8*4%3*0.5+1)
% (c / ($v1*8%2*2+2) )
+ $v1*8*8%5*(c/8)
// Same but also with pitch
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

( $v1 * c * 8 ) / 1 % (c/($v1*8%2*7+1)) + $v1*8*8%6*(c/8) + $v1*c*8%(sin($v1*4)*10+12) * ($v1*8*8%3%2)
// Remove pitch but add distortion (also changed a little the sequence)
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 20) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

// I'll show you one last trick: All this can be handled with an if() to let the ground kick... $v1*8*8%4 is 0 only on the first 1/8 measure of each pattern (when the kick and snare are!)
if ($v1*8*8%4, ($v1*c*8)/(3-$v1*4%3)+ $v1*c*8%(sin($v1*4)*10+12)*($v1*8%3%2), $v1*c*8)
@ sin(4000/($v1*2%c)) * 0.25 * 1
+ sin($v1*sin($v1*($v1/c%2*8+1)%($v1*8/c%7))) * pow(1-$v1*8%c/c, $v1*8/c%9+1) * 0.15 * 1
+ sin($v1*sin($v1%20)) * pow(1-$v1%c/c, 10) * 0.2 * 1
+ sin($v1/16 + sin($v1/16*3) * ($v1*8/c%3*2+1) * pow(1-$v1*4%c/c, 1.5)) * 0.075 * 1;

// 6. GRANULAR SYNTHESIS

// Perhaps you already noticed that some of the tricks I show above are actually granular synthesis. When we skip some measures or add a little noise to distort the ramp in the ramp control section we are already doing some granular stuff. Here I'll show you how to do it more radical.

hz @ 1.0 / 8;
$v1 * 8 * c @ sin(c/($v1%c)*5)*0.1;

// For now on, just pay attention to the ramp control section and forget about the rest.

// Firt take a grain. You can make a little loop like this:

$v1 * 8 * c % 500 @ sin(c/($v1%c)*5)*0.1;
$v1 * 8 * c % 100 @ sin(c/($v1%c)*5)*0.1;
// %100 and %500 are different grain size.

$v1 * 8 * c % 100 + $v1/4 * c @ sin(c/($v1%c)*5)*0.1;
$v1 * 8 * c % 10 + $v1/4 * c @ sin(c/($v1%c)*5)*0.1;
// Now we add a slow movement forward.

$v1 * 8 * c
@ sin(c/($v1*4%c)*5)*0.1*($v1*4/c%8*5%8<5) + sin($v1*sin($v1))*(1-$v1*8%c/c)*($v1*8/c%12*5%12<5)*0.1 + sin($v1+sin($v1)*9) * (1-$v1*32%c/c) * ($v1*8/c%32*7%32<7) * 0.1 + $v1/($v1/c*16%2+1)/32%2*0.1*($v1*8/c%11*4%11<4);
// This is just a loop to mess with...

$v1 * 8 * c %1000 + $v1/2 * c
@ sin(c/($v1*4%c)*5)*0.1*($v1*4/c%8*5%8<5) + sin($v1*sin($v1))*(1-$v1*8%c/c)*($v1*8/c%12*5%12<5)*0.1 + sin($v1+sin($v1)*9) * (1-$v1*32%c/c) * ($v1*8/c%32*7%32<7) * 0.1 + $v1/($v1/c*16%2+1)/32%2*0.1*($v1*8/c%11*4%11<4);
// With an 1/8 measure it sounds kind of a delay effect.

$v1 * 16 * c %200 + $v1/2 * c
@ sin(c/($v1*4%c)*5)*0.1*($v1*4/c%8*5%8<5) + sin($v1*sin($v1))*(1-$v1*8%c/c)*($v1*8/c%12*5%12<5)*0.1 + sin($v1+sin($v1)*9) * (1-$v1*32%c/c) * ($v1*8/c%32*7%32<7) * 0.1 + $v1/($v1/c*16%2+1)/32%2*0.1*($v1*8/c%11*4%11<4);
// Try smaller grain sizes.

$v1 * 8 * c %10 + $v1*8*256%8*c/4 + $v1/8 * c
@ sin(c/($v1*4%c)*5)*0.1*($v1*4/c%8*5%8<5) + sin($v1*sin($v1))*(1-$v1*8%c/c)*($v1*8/c%12*5%12<5)*0.1 + sin($v1+sin($v1)*9) * (1-$v1*32%c/c) * ($v1*8/c%32*7%32<7) * 0.1 + $v1/($v1/c*16%2+1)/32%2*0.1*($v1*8/c%11*4%11<4);
// +$v1*8*256%8*c/4 is a fast offset, a common feature in granular synths.

hz @ 1.0 / 32;
$v1 * 32 * c %10 + $v1*32*256%8*c/4 + $v1/32 * c
@ sin(c/($v1*4%c)*5)*0.1*($v1*4/c%8*5%8<5) + sin($v1*sin($v1))*(1-$v1*8%c/c)*($v1*8/c%12*5%12<5)*0.1 + sin($v1+sin($v1)*9) * (1-$v1*32%c/c) * ($v1*8/c%32*7%32<7) * 0.1 + $v1/($v1/c*16%2+1)/32%2*0.1*($v1*8/c%11*4%11<4);
// Another example of the same offset trick. This time, I made the general loop larger (32 * c) so there is more variation.


// 7. EUCLIDEAN RHYTHMS

// The rhythmic loop above is made with an euclidean technique. It seems we're always one step further. I took the formula from pd_777 YouTube channel and it goes like this:

// ($v1*measure/c % steps * triggers % steps < triggers) like in ($v1*8/c %16*5%16<5), which means "trigger 5 measures distributed in 16 steps".

// If you didn't know anything about euclidean check it on the web, there is a lot of information and it is a very interesting and useful subject, specially for rampcode patterns.

hz @ 1.0 / 8;
$v1 * c * 8
@ sin($v1*2)*pow(1-$v1*8%c/c,8)*0.15*($v1*8/c%16*5%16<5)
+ sin(c/8/($v1*8%c)*2)*0.15*($v1*8/c%16%7*4%7<3)
+ sin($v1%66 * sin ($v1)) * pow(1-$v1*8%c/c,2) * 0.1 * ($v1*8/c%32*17%32<17)
+ sin($v1/16 + sin($v1/16) * 30 * pow(1-$v1*8%c/c,5)) * 0.08 * ($v1*2/c%8*5%8>5)
+ sin($v1/($v1*2%5+1))*sin($v1*64/c)*($v1*2/c%33*7%33<7)*0.033;
// Just play with this one changing the parameters of the eucludean triggers.

// Two more examples of this loop combined with granular technique.

hz @ 1.0 / 64;
$v1 * c * 64 % 1000 + $v1 * 8 * c
@ sin($v1*2)*pow(1-$v1*8%c/c,8)*0.15*($v1*8/c%16*5%16<5)
+ sin(c/8/($v1*8%c)*2)*0.15*($v1*8/c%16%7*4%7<3)
+ sin($v1%66 * sin ($v1)) * pow(1-$v1*8%c/c,2) * 0.1 * ($v1*8/c%32*17%32<17)
+ sin($v1/16 + sin($v1/16) * 30 * pow(1-$v1*8%c/c,5)) * 0.08 * ($v1*2/c%8*5%8>5)
+ sin($v1/($v1*2%5+1))*sin($v1*64/c)*($v1*2/c%33*7%33<7)*0.033;

hz @ 1.0 / 64;
$v1 * c * 64 %250 + $v1 * 64 * 640 % 5 * c/2 + $v1 * c
@ sin($v1*2)*pow(1-$v1*8%c/c,8)*0.15*($v1*8/c%16*5%16<5)
+ sin(c/8/($v1*8%c)*2)*0.15*($v1*8/c%16%7*4%7<3)
+ sin($v1%66 * sin ($v1)) * pow(1-$v1*8%c/c,2) * 0.1 * ($v1*8/c%32*17%32<17)
+ sin($v1/16 + sin($v1/16) * 30 * pow(1-$v1*8%c/c,5)) * 0.08 * ($v1*2/c%8*5%8>5)
+ sin($v1/($v1*2%5+1))*sin($v1*64/c)*($v1*2/c%33*7%33<7)*0.033;


// Yeah, that was a lot of information but don't be affraid of trying things and please write me if you have any question or want to share your creations:

// gabochi
// gabriel.vinazza@gmail.com
// ig: @gabovinazza
// fb: /gedeaudiovisual
